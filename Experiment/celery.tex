\section{Celery Queues}
\label{exp:Celery}
We used a Celery task queue running on RabbitMQ to overcome the GIL. According to Celery Project Homepage \cite{Celery}:
\begin{quotation}
``Celery is an asynchronous task queue/job queue based on distributed message passing.''
\end{quotation}

Simply put, Celery allows us to process multiple tasks in parallel by making use of what is known as a task queue. Celery instantiates multiple workers that listen to these queues and processes each task individually. This simulates pseudo-parallel processing to a certain degree, by allowing us to run multiple instances of the same program. It does this by using a message broker called RabbitMQ.
According to RabbitMQ's Wikipedia page \cite{wiki:RabbitMQ},
\begin{quotation}
``RabbitMQ is an open source message broker software that implements the Advanced Message Queuing Protocol (AMQP)''
\end{quotation}
RabbitMQ facilitates the storage and transport of messages on queuing systems. It is also cross-platform and open source, providing us with clients and servers for many different languages, thereby being the ideal fit for Celery.
Thus, by using Celery and RabbitMQ together, we were able to achieve a certain degree of parallelism that would not have been possible with traditional Python.

%The next chapter presents our results and showcases our analysis of the said results.
